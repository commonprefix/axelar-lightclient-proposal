\section{On-Chain Light Client}

In this section, we explore on-chain light clients as a solution for
implementing a bridge between Axelar and Ethereum. First, we discuss the
high-level benefits of such construction. Following, we review multiple
candidate solutions for implementing on-chain light clients, before finally
offering our recommendation for this particular instance.

\subsection{Merits of an On-Chain Light Client}

There are various advantages in using an on-chain light client, compared to
relying on the committee of attestors. Briefly, this solution guarantees safety
and, consequently, enables on-chain healing in the presence of temporary
adversarial majority.  We note that our work focuses on the setting where the
RPC providers, which attestors use to access Ethereum's full chain, get
corrupted. In this case, the attestors are honest, but the data that they
receive are corrupted.

In detail, on-chain light clients preserve of \emph{bridge safety} at all
times, since Axelar's honest nodes will not accept an
incorrect statement about an Ethereum transaction.
%
This is in contrast with the existing design. Currently, the client accepts a
statement as long as it is validated by Axelar's attestors. If these attestors
use rely on RPC providers, they might unwittingly validate incorrect (Ethereum)
transaction data, which would be accepted by Axelar full nodes. Using an
on-chain light client avoids this problematic scenario, since the Axelar nodes
accept statements about Ethereum transactions only if accompanied by a valid
proof. 

Currently, if safety is violated it is unclear how Axelar could recover.
Specifically, it cannot resolve the situation within the consensus protocol, so
external intervention would be needed, e.g., a (slow and cumbersome) social
consensus mechanism.  external intervention.
The preservation of safety via the on-chain light client solution directly
enables a healing mechanism. Specifically, Axelar's attestors could switch RPC
providers and, after obtaining the correct Ethereum data, bridge liveness would
be restored, whilst safety is guaranteed throughout the process.

\subsection{On-Chain Light Client Alternatives}\label{subsec:alternatives}

We now present an array of solutions for the on-chain light client. For each
solution we give a high-level overview, highlighting its mechanics as well as
possible shortcomings. Each alternative offers different features and relies on
different assumptions. 

We note that all solutions require that at least one Axelar attestor is honest,
in order to guarantee liveness. Additionally, all solutions, except the first,
rely on Ethereum's sync committee.

\subsubsection{SPV Light Client (sampling validators)}

The first solution makes use of Ethereum's validators. In particular, we assume
that there exists a mechanism for sampling some of the signatures that were
produced by the validators on each block. To verify an Ethereum block, the
light client checks:
i) that the sampling process was done correctly (e.g., following a verifiable pseudorandom process);
ii) that the provided signatures correspond to active Ethereum validators;
iii) that enough signatures have been provided to guarantee the block's correctness.

An advantage of this solution is the non-reliance on the sync committee. In
particular, the only assumption that is needed is that Ethereum is safe and
live (which is already assumed) and that the probability of sampling
adversarial signatures is negligible.

However, it also presents various shortcomings.
First, Ethereum's consensus relies on Casper FFG~\cite{buterin2017casper} and
LMD-GHOST. This is particularly complicated and it is unclear how a secure
signature sampling process can be implemented.
Second, it is unclear how the light client can retrieve the active Ethereum
validators at any point in time. In particular, assuming that the light client
starts from a trusted block header, it is unclear how to obtain each following
period's validators, in a succinct and efficient manner.

\subsubsection{SPV Light Client (Sync committee)}

This solution makes direct use of Ethereum's sync committee. In particular,
each sync committee is recorded on Axelar. When an attestor wants to bridge a
transaction from Ethereum to Axelar, it accompanies it with a proof of
inclusion in a block that has been validated by the corresponding sync
committee. Following, when an Axelar full nodes wants to validate an Ethereum
transaction that has been bridged to Axelar, it first identifies (on Axelar's
chain) the sync committee and that corresponds to the transaction and then
validates the proof w.r.t. it.

This scheme assumes that, at the bridge's onset, the sync committee is recorded
on Axelar correctly. In other words, the first sync committee that is recorded
on Axelar should be correct. Following, each update to the sync committee is
accompanied by a proof of a handover, that is an Ethereum block that has been
signed by the previous committee. Note that, even if Axelar's security is
compromised, the adversary cannot produce a proof of a handover to an invalid
sync committee (since this depends on the sync committee's security).
Therefore, the honest Axelar nodes will always hold a valid list of sync
committees (albeit this could possibly be outdated, if liveness is violated).

Additionally, in order to validate an Ethereum transaction, Axelar's full nodes
should have access to an Ethereum full node (in order to validate the proof).
Again though, even if the full node is adversarial, it cannot convince the
Axelar node of an invalid Ethereum transaction (safety violation), but only
refuse to respond to the node's queries (safety violation); in this case, the
Axelar node can simply switch Ethereum full nodes until it connects to an
honest one.

The major advantage of this solution is that it is straightforward to
implement. In particular, the sync committee has already been implemented in
Ethereum and there exists a large body of community projects and tools that
could be reused in Axelar's case, such as
Kevlar\footnote{\url{https://github.com/lightclients/kevlar}} and
Helios\footnote{\url{https://github.com/a16z/helios}}.

There are some disadvantages with this solution though. First, it relies on the
security of Ethereum's sync committee. Second, the storage requirements
increase linearly over time, since each sync committee (which is updated
approx. every day) is recorded on Axelar's chain. This can result in
significant storage overhead, since the mechanism requires approx. $25$KB per
committee~\cite{sync-committee}.

% TODO(shresth): rename to referreed, cite PoPoS
\subsubsection{Refereed Light Client}

This mechanism makes use of Ethereum's sync committee in a manner similar as
the previous solution, but aiming to reduce the storage requirements. 

In brief, the idea is to (optimistically) assume that an attestor provides
honest data about the updated sync committees and enable a dispute resolution
mechanism in case the attestor is malicious. Specifically, we assume that the
bridge is updated every $x$ (sync committee) periods. In the previous
solution, each committee is recorded on Axelar's chain. Here, there exists an
Axelar attestor who collects the $x$ committees, each corresponding to the sync
committees for the corresponding periods, and publishes a commitment to them on
Axelar altogether. If the attestor is honest, then the commitment should be
correct.  Therefore, the other Axelar nodes can ``fast-forward'' these $x$
committees.

Nonetheless, the attestor might be malicious and submit an incorrect
commitment. To cover this possibility, there exists a contest period, during
which another attestor can challenge the first attestor's submission. The
challenger provides an alternative commitment, at which point the dispute needs
to be resolved. This is done by opening both commitments and identifying the
point of divergence between the two committee lists. At this point, both
attestors are required to submit proof of correct transition, that is to reveal
the (sync committee) keys that correspond to the last agreed committee along
with (this committee's) signatures on the keys that correspond to the first
committee of disagreement. Since the sync committee is presumed honest, one of
the two lists will be revealed as fraudulent, since it should be impossible to
provide the necessary signatures that validate the transition under question.

We propose two manners in which the commitment can be implemented.

\paragraph{Linear}
In this case, the commitment is a list of hashes, with each hash corresponding
to a sync committee. The main benefit of this solution is that disputes can be
resolved easily, since the point of disagreement can be identified directly by
parsing the two lists. However, the asymptotic complexity of this solution is
again linear on the number of committees, albeit the constant factor (which is
only a hash in the optimistic case) is significantly smaller than the previous
solution.

% TODO(shresth): cite lazylight
\paragraph{Bisection}
Here, the commitment is a Merkle tree, the leaves of which correspond to each
sync committee. Now, the constant factor of the storage complexity is even
smaller (in the optimistic case), since only one hash every $x$ committees
needs to be published. However, dispute resolution is more costly, at
logarithmic complexity on $x$ (since the Merkle branches of the two committees
at the point of disagreement need to be revealed).

Finally, we note that the advantage of the refereed light client solution only
manifests if the bridge is synchronized infrequently and dispute resolutions
are rare. If, for example, the bridge is synchronized every day (that is, $x =
1$), then the benefit is marginal even in the optimistic case. In addition,
implementing a dispute resolution mechanism securely adds complexity. Finally,
the length of the contest period affects the bridge's latency, since it should
be large enough s.t. an honest party can challenge an invalid commitment, but
small enough to avoid increasing latency significantly.

\subsubsection{SNARK Light Client}

The final solution is based on zero-knowledge, namely SNARK proofs (Succinct
Non-interactive ARguments of Knowledge). The goal of this solution is to reduce
the proof of validity of each bridged Ethereum transaction.

The setup of this solution is similar to the sync committee-based solution
above. Specifically, each committee is published on Axelar, along with a proof
of handover for the committee transitions. 

In particular, when an attestor wants to bridge an Ethereum transaction to
Axelar, it produces a zero-knowledge proof. This proof replaces the aggregate
public key and signatures, which were used before for validation. Instead, it
proves that there exists a quorum of at least $\frac{2}{3}$ sync committee
members that have signed the transaction under question.

The main advantage of this solution is that SNARKs can be very efficient in
terms of proof sizes. For example, a Groth16~\cite{EC:Groth16} proof consists
of only $2$ group elements, that is approx. $209$ bytes. However, we note that
the problem under question is not one of efficient bootstrapping, as is the
usual use case for SNARKs, but obtaining the latest state of Ethereum at any
point in time. This is relevant because recursion, which is a major feature in
terms of efficiency, can be used only on chains of increasing length, which is
not our case.

One main disadvantage of this solution is implementation complexity and cost.
Securely implementing ZK-SNARKs can be particularly challenging, even more so
since they have been developed fairly recently. Additionally, the cost of
generating a SNARK can be particularly high. For example,
% have expensive provers. For example,
according to \cite{zkbridge}, proving consensus (of $128$ validators)
on \emph{one} Cosmos block
% (with $128$ validators)
takes $18$ seconds on $32$ instances of Amazon AWS \texttt{c5.24xlarge}.
(We are unable to independently reproduce this finding because the authors of
zkBridge have not disclosed their code.)
% The implementation of zkBridge is not open source, so we could
% not reproduce the calculations.
At Cosmos' block rate of $1$ block per second,
that would require
% The paper's experiments cost
$18 \times 32$ continuously operating \texttt{c5.24xlarge} instances,
costing annually
\$12,967,488 on Amazon AWS (annual pricing, \texttt{us-east-1} region, June 2023),
or \$1,749,600 on Hetzner's equivalents.
Scaling this proportionally for Ethereum
($\times 4$ for sync committee size $512$, $/12$ for block rate $1$ block per $12$ seconds)
yields an estimate of \$583,333 annually.

\subsubsection{Comparison}

Table~\ref{tab:comparison} summarizes the comparison of the alternatives
presented above. Note that, in all cases, Ethereum is assumed safe and live, as
well as, in order to guarantee bridge liveness, we assume that at least one
Axelar attestor is honest (in some cases, this assumption is needed also for
bridge safety).

\begin{table}
    \centering %\def\arraystretch{1.3}
    \resizebox{\columnwidth}{!}{
    \footnotesize
    \begin{tabular}{|c|c|c|c|c|c|} 
        \hline
        \multirow{2}{*}{} & \multirow{2}{*}{ \textbf{Sampling} } & \multirow{2}{*}{ \begin{tabular}[c]{@{}c@{}} \textbf{Sync} \\ \textbf{Committee} \end{tabular} } & \multicolumn{2}{c|}{ \textbf{Refereed} } & \multirow{2}{*}{ \textbf{SNARK} } \\
        \cline{4-5}
        & & & \textbf{Linear} & \textbf{Bisection} & \\
        \hline
        \begin{tabular}[c]{@{}c@{}} \emph{Proof Size} \\ \emph{(Annual)} \end{tabular} & $365 \cdot 25$ KB & $365 \cdot 25$ KB & $\frac{365}{x} \cdot (25\text{KB} + x \cdot 32\text{B})$ & $\frac{365}{x} \cdot  (25\text{KB} + 32\text{B})$ & $365 \cdot (209 + 32)$ B \\
        \hline
        \emph{Non-interactive} & \cmark & \cmark & \xmark & \xmark & \cmark \\
        \hline
        \begin{tabular}[c]{@{}c@{}} \emph{Doesn't rely on} \\ \emph{Sync Committee} \end{tabular} & \cmark & \xmark & \xmark & \xmark & \xmark \\
        \hline
        \begin{tabular}[c]{@{}c@{}} \emph{Extra Safety} \\ \emph{Assumptions} \end{tabular} & - & - & \begin{tabular}[c]{@{}c@{}} Exists honest \\ Axelar attestor \end{tabular} & \begin{tabular}[c]{@{}c@{}} Exists honest \\ Axelar attestor \end{tabular} & - \\
        \hline
        \begin{tabular}[c]{@{}c@{}} \emph{Implementation} \\ \emph{Complexity} \end{tabular} & High & Low & Medium & Medium & High \\
        \hline
        \begin{tabular}[c]{@{}c@{}} \emph{Prover Cost}\\ \emph{Annually} \end{tabular} & \$600  & \$600  & \$600 & \$600 & >\$500,000 \\
        \hline
    \end{tabular}
    }
    \caption{Comparison of alternative solutions. All solutions assume that: i)
    Ethereum is secure (safe and live); ii) to guarantee bridge liveness, there
    exists an honest Axelar attestor. In the refereed case, we assume that the
    bridge is updated every $x$ days (where $1$ sync committee period is equal
    to approx. $1$ day). Also, in the refereed case we compute the best-case
    scenario, where no disputes occur. In the SNARK case we assume the usage of
    Groth16 proofs.}
    \label{tab:comparison}
\end{table}

\subsubsection*{Our recommendation}

We recommend implementing the second option, that is an SPV client that relies
on the sync committee.

From the above comparison, it is evident that the
first option (SPV client with Ethereum validator sampling) is rather
experimental and requires significant research work before proceeding with
implementation.

Due to the high traffic that the bridge is expected to observe, it will most
probably need to be updated at least on a daily basis, so the main
benefit of the refereed options would be lost.

Finally, the exceptional cost of creating SNARK proofs at this point in time
makes it prohibitively expensive as an option. Nonetheless, we will design the
bridge in a modular way, such that a SNARK solution can be easily incorporated
in the future, when proof creation becomes more cost efficient.
