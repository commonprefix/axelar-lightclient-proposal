\section{On-Chain Light Client}

In this section, we explore on-chain light clients as a solution for
implementing a bridge between Axelar and Ethereum. First, we discuss the
high-level benefits of such construction. Following, we review multiple
candidate solutions for implementing on-chain light clients, before finally
offering our recommendation for this particular instance.

\subsection{Merits of an On-Chain Light Client}

There are various advantages in using an on-chain light client, compared to
relying on the committee of attestors. Briefly, this solution guarantees safety
and, consequently, enables on-chain healing in the presence of temporary
adversarial majority.  We note that our work focuses on the setting where the
RPC providers, which attestors use to access Ethereum's full chain, get
corrupted. In this case, the attestors are honest, but the data that they
receive are corrupted.

In detail, on-chain light clients preserve of \emph{bridge safety} at all
times, since Axelar's honest nodes will not accept an
incorrect statement about an Ethereum transaction.
%
This is in contrast with the existing design. Currently, the client accepts a
statement as long as it is validated by Axelar's attestors. If these attestors
use rely on RPC providers, they might unwittingly validate incorrect (Ethereum)
transaction data, which would be accepted by Axelar full nodes. Using an
on-chain light client avoids this problematic scenario, since the Axelar nodes
accept statements about Ethereum transactions only if accompanied by a valid
proof. 

Currently, if safety is violated it is unclear how Axelar could recover.
Specifically, it cannot resolve the situation within the consensus protocol, so
external intervention would be needed, e.g., a (slow and cumbersome) social
consensus mechanism.  external intervention.
The preservation of safety via the on-chain light client solution directly
enables a healing mechanism. Specifically, Axelar's attestors could switch RPC
providers and, after obtaining the correct Ethereum data, bridge liveness would
be restored, whilst safety is guaranteed throughout the process.

\subsection{On-Chain Light Client Alternatives}\label{subsec:alternatives}

We now present an array of solutions for the on-chain light client. For each
solution we give a high-level overview, highlighting its mechanics as well as
possible shortcomings. Each alternative offers different features and relies on
different assumptions. 

We note that all solutions require that at least one Axelar attestor is honest,
in order to guarantee liveness. Additionally, all solutions, except the first,
rely on Ethereum's sync committee.

\subsubsection{SPV Light Client (sampling validators)}

The first solution makes use of Ethereum's validators. In particular, we assume
that there exists a mechanism for sampling some of the signatures that were
produced by the validators on each block. To verify an Ethereum block, the
light client checks:
i) that the sampling process was done correctly (e.g., following a verifiable pseudorandom process);
ii) that the provided signatures correspond to active Ethereum validators;
iii) that enough signatures have been provided to guarantee the block's correctness.

An advantage of this solution is the non-reliance on the sync committee. In
particular, the only assumption that is needed is that Ethereum is safe and
live (which is already assumed) and that the probability of sampling
adversarial signatures is negligible.

However, it also presents various shortcomings.
First, Ethereum's consensus relies on Casper FFG~\cite{buterin2017casper} and
LMD-GHOST. This is particularly complicated and it is unclear how a secure
signature sampling process can be implemented.
Second, it is unclear how the light client can retrieve the active Ethereum
validators at any point in time. In particular, assuming that the light client
starts from a trusted block header, it is unclear how to obtain each following
period's validators, in a succinct and efficient manner.

\subsubsection{SPV Light Client (Sync committee)}

This solution makes direct use of Ethereum's sync committee. In particular,
each sync committee is recorded on Axelar. When an attestor wants to bridge a
transaction from Ethereum to Axelar, it accompanies it with a proof of
inclusion in a block that has been validated by the corresponding sync
committee. Following, when an Axelar full nodes wants to validate an Ethereum
transaction that has been bridged to Axelar, it first identifies (on Axelar's
chain) the sync committee and that corresponds to the transaction and then
validates the proof w.r.t. it.

This scheme assumes that, at the bridge's onset, the sync committee is recorded
on Axelar correctly. In other words, the first sync committee that is recorded
on Axelar should be correct. Following, each update to the sync committee is
accompanied by a proof of a handover, that is an Ethereum block that has been
signed by the previous committee. Note that, even if Axelar's security is
compromised, the adversary cannot produce a proof of a handover to an invalid
sync committee (since this depends on the sync committee's security).
Therefore, the honest Axelar nodes will always hold a valid list of sync
committees (albeit this could possibly be outdated, if liveness is violated).

Additionally, in order to validate an Ethereum transaction, Axelar's full nodes
should have access to an Ethereum full node (in order to validate the proof).
Again though, even if the full node is adversarial, it cannot convince the
Axelar node of an invalid Ethereum transaction (safety violation), but only
refuse to respond to the node's queries (safety violation); in this case, the
Axelar node can simply switch Ethereum full nodes until it connects to an
honest one.

The major advantage of this solution is that it is straightforward to
implement. In particular, the sync committee has already been implemented in
Ethereum and there exists a large body of community projects and tools that
could be reused in Axelar's case, such as
Kevlar\footnote{\url{https://github.com/lightclients/kevlar}} and
Helios\footnote{\url{https://github.com/a16z/helios}}.

There are some disadvantages with this solution though. First, it relies on the
security of Ethereum's sync committee. Second, the storage requirements
increase linearly over time, since each sync committee (which is updated
approx. every day) is recorded on Axelar's chain.

% TODO(shresth): rename to referreed, cite PoPoS
\subsubsection{Optimistic Light Client}

The goal of this mechanism is for the client to avoid updating the sync
committee in full if the bridge faces many (sync committee) periods of
inactivity.

Specifically, consider the case when the bridge is updated every $x$ (sync
committee) periods. In the previous solution, the Axelar nodes (who run an
Ethereum light client) need to keep track of all $x$ sync committees, despite
the lack of bridge traffic. In the current solution, there exists an Axelar
attestor who submits a list of $x$ hashes, each corresponding to the chain of
sync committees for the corresponding periods. If the attestor is honest, then
the hash list should be correct. Therefore, the other Axelar nodes can
``fast-forward'' the committees.

Nonetheless, the attestor might be malicious and submit an incorrect list. To
cover this possibility, there exists a contest period, during which another
attestor can challenge the first attestor's submission. The challenger provides
an alternative list, at which point the dispute needs to be resolved.  This is
done by identifying the point of divergence between the two lists. At this
point, both attestors are required to submit proof of correct transition, that
is to reveal the (sync committee) keys that correspond to the last agreed hash
along with (this committee's) signatures on the keys that correspond to the
first hash of disagreement. Since the sync committee is presumed honest, one of
the two lists will be revealed as fraudulent, since it should be impossible to
provide the necessary signatures that validate the transition under question.

There are various benefits in this mechanism. First, the construction is simple
and intuitive. Second, the proof's size is relatively small, equal to a hash's
size times the number of sync committee periods per bridge synchronization.

However, the advantage of this solution only manifests if the bridge is
synchronized infrequently. If, for example, the bridge is synchronized every
day (that is, one sync committee period), then the proof size is the same as the
previous section's, while the latency increases due to the existence of the contest period.

% TODO(shresth): cite lazylight
\subsubsection{Bisection Light Client}

This solution is similar to the previous optimistic solution. In this case,
instead of submitting a list of hashes, the attestor organizes the sync
committee hashes in a Merkle tree and submits its root.

The main advantage over the previous solution is that the proof size is
constant, in the optimistic case. In addition, in the case of a challenge, the
parties need to reveal a logarithmic number of values, which correspond to the
Merkle branch (hence the name ``bisection'', which refers to the dispute
resolution mechanism).

However, the improvements here are only incremental compared to the above
optimistic alternative. Notably, the bisection solution suffers from the same
disadvantages which, under high traffic, make it not particularly useful.

\subsubsection{SNARK Light Client}

The final solution which is discussed here is based on zero-knowledge, namely
SNARK proofs (Succinct Non-interactive ARguments of Knowledge).

Briefly, an attestor creates a proof that an Ethereum block has been signed by
enough members of the sync committee. Following, it publishes the block's
header on Axelar, along with the proof, such that every Axelar client can
validate it in a non-interactive manner.

One advantage of this solution is that SNARKs can be very efficient in terms of
proof sizes. For example, a Groth16~\cite{EC:Groth16} proof consists of only
$2$ group elements. However, we note that the problem under question is not one
of efficient bootstrapping, as is the usual use case for SNARKs, but obtaining
the latest state of Ethereum at any point in time. This is relevant because
recursion, which is a major feature in terms of efficiency, can be used only on
chains of increasing length, but not when facing incremental changes in a
state, as is our case.

One main disadvantage of this solution is implementation complexity. Securely
implementing ZK-SNARKs can be particularly challenging, even more so since they
have been developed fairly recently.

- plonk
- holo2
\textbf{--- DK: also not sure about these so leaving them for now ---}

% TODO(shresth): add a table
\subsubsection{Comparison}

Let us now offer a summarized comparison of all outlined solutions above.

\noindent\textbf{Interactivity.}
Both SPV solutions (either sampling Ethereum validators' signatures or using
the sync committee), as well as the SNARK-based solution are non-interactive,
in the sense that the proof can be validated by all other Axelar validators
non-interactively. The optimistic and bisection solutions are interactive,
since the validators need to actively engage in the case of a dispute.

\noindent\textbf{Safety Assumptions.}
All solutions require Ethereum to be safe. In the SPV and SNARK solutions, this
is the only assumption. The optimistic and bisection solutions also assume
existential honestly of Axelar attestors, such that a fraudulent submission is
challenged (within the contest period of time).
% - safety assumptions
%     - eth safety/liveness
%     - axelar validators
%     - axelar attesters

\noindent\textbf{Liveness Assumptions.}
As with safety, all solutions require Ethereum to be live. In addition, all
solutions require at least one Axelar attestor to be honest, in order to
publish the updated Ethereum state along with the necessary proof.

\noindent\textbf{Implementation Complexity.}
For the SPV solution that utilizes the sync committee the implementation
complexity is relatively low, since the sync committee is already offered as a
feature on Ethereum and its incorporation in the Axelar client is fairly
straightforward. The complexity of the optimistic and bisection alternatives is
medium, since an analysis is required around the details of the dispute
resolution mechanism and the duration of the contest period. Finally, the SPV
sampling and the SNARK-based alternatives are highly complicated; in the
former, a thorough analysis is needed on implementing a secure sampling
mechanism; in the latter, implementing and using zero-knowledge proof systems
is non-trivial.

\noindent\textbf{Proof Size.}
In the SPV sampling solution, the proof size depends on the number of sampled
(Ethereum validators') signatures, so it is unclear at this point how large it
should be. In the SPV sync committee based solution, the proof size corresponds
to the BLS signatures of the sync committee validators, which should be on the
order of a few hundred bytes~\cite{sync-committee}.
\textbf{--- DK: TODO proof sizes for optimistic, bisection, SNARK ---}

\noindent\textbf{Ethereum Sync Committee Reliance.}
All solutions, except the first, rely on a secure sync committee. In
particular, if the sync committee becomes malicious then it can sign a
malicious block header which would result in a compromise of Axelar's bridge.

- accountability
- historical validity
\textbf{--- DK: also not sure about these so leaving them for now ---}

\subsubsection{Our recommendation}
